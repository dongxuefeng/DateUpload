#include "SocketServer.h"
#include <Windows.h>#include "tchar.h"#include "socketServer.h"#include <ostream>#include <string>#include <map>#include <windows.h>#include <list>#include <stdio.h>#include <stdlib.h>#include <string.h>#include "cxx_xml.h"#include "cxx_xml.h"
DWORD WINAPI ProcessClientRequests(LPVOID lpParam){	client_info *client = (client_info *)lpParam;	SOCKET clientSocket = (SOCKET)client->sock;  //这里需要强制转换，注意：指针类型的	char buffer[MAX_XML_BYTE] = { 0 };	char strtmp[MAX_XML_BYTE] = { 0 };//	int result = -1;	int count = 0;	string msg = "error";	string valdate;	int recv_count = 0;	fd_set         fdread;	int             ret;	struct timeval tv = { 10, 0 };	while (TRUE)	{		memset(buffer, 0, MAX_XML_BYTE);		memset(strtmp, 0, MAX_XML_BYTE);		FD_ZERO(&fdread);		FD_SET(clientSocket, &fdread);		// We only care read event 		ret = select(clientSocket + 1, &fdread, NULL, NULL, &tv);		if (ret == 0)		{       // Time expired 			printf("time out clientSocket ===============%d\n", clientSocket);			break;		}		recv_count = recv(clientSocket, buffer, MAX_XML_BYTE, NULL);		//	printf("recv_count ===========%d\n",recv_count);		if (recv_count > 0)		{			code_convert("UTF-8", "GB2312", buffer, MAX_XML_BYTE, strtmp, MAX_XML_BYTE);			printf(strtmp);			result = parse_xiangx_xml(strtmp, valdate);			if (0 == result)			{				printf("%s", valdate.c_str());				count++;				printf("socket = %d,count = %d\n", clientSocket, count);				send(clientSocket, valdate.c_str(), sizeof(int), NULL);			}			else			{				printf("parse error!");				printf(strtmp);				send(clientSocket, msg.c_str(), strlen(msg.c_str()) + sizeof(char), NULL);			}		}		else if (recv_count == 0)		{			break;			//	printf("socket = %d\n",clientSocket);		}		else if (recv_count == -1)		{			printf("erorr === %d\n", WSAGetLastError());			break;		}		Sleep(5);	}	existingClientCount--;	closesocket(clientSocket);	delete client;	return 0;}int _tmain(int argc, TCHAR* argv[], TCHAR* envp[]){	WSADATA wsaData;	WSAStartup(MAKEWORD(2, 2), &wsaData);	HANDLE threads;	SOCKET socLink = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);	sockaddr_in sockAddr;	sockAddr.sin_family = PF_INET;	sockAddr.sin_addr.S_un.S_addr = INADDR_ANY;	sockAddr.sin_port = htons(5522);	bind(socLink, (SOCKADDR*)&sockAddr, sizeof(SOCKADDR));	listen(socLink, 1);	string test = "";	//parse_xiangx_xml("",test);//gengming test	while (TRUE)	{		SOCKADDR clientAddr;		int size = sizeof(SOCKADDR);		SOCKET clientSocket;		clientSocket = accept(socLink, &clientAddr, &size);		if (-1 == clientSocket)		{			continue;		}		client_info *client = new client_info;		client->sock = clientSocket;		sockaddr_in *p = (sockaddr_in *)(&clientAddr);		strcpy(client->ip, inet_ntoa(p->sin_addr));		//if(existingClientCount<MAXCLIENTS)       //判断是否已经超出最大连接数了		{			threads = CreateThread(NULL, 0, ProcessClientRequests, (LPVOID)client, 0, NULL);  //启动新线程，并且将socket传入			if (threads == 0)			{				printf("create thread failed!");				closesocket(clientSocket);				delete client;				continue;			}			existingClientCount++;			printf("existingClientCount===%d\n", existingClientCount);		}		/*else		{		char* msg="Exceeded Max incoming requests, will refused this connect!\r\n";		send(clientSocket, msg, strlen(msg)+sizeof(char), NULL);       //发送拒绝连接消息给客户端		printf("***SYS***    REFUSED.\n");		closesocket(clientSocket);                              //释放资源		break;		}*/	}	printf("Maximize clients occurred for d%.\r\n", MAXCLIENTS);	WaitForMultipleObjects(MAXCLIENTS, &threads, TRUE, INFINITE);           //等待所有子线程，直到完成为止	closesocket(socLink);	CloseHandle(threads);                              //清理线程资源	WSACleanup();	printf("Cleared all.\r\n");	getchar();	exit(0);}//解析每一个xml,提取车辆信息int parse_xiangx_xml(const char *xmlBuff, string &valdate){	string strxml = "";	char reftest[1024];	/*xmlDocPtr doc;   //xml整个文档的树形结构	xmlNodePtr cur;  //xml节点	xmlNodePtr curChild;  //xml节点*/	c_data_convert_xxpasscar* passcar;	c_data_convert_xxviodata* viodata;	int iresult = 0;	int xml_type = 0;	//   char tempStr[2048];	//FILE *fp = fopen("E://wf3.xml" , "r");//	//fseek(fp,0,SEEK_END);	//int i =ftell(fp);	//fseek(fp,0,SEEK_SET);	//fread(tempStr,i,sizeof(char),fp);	//解析xml字符串 		cxx_xml* ehl_con = new cxx_xml();	ehl_con->readxml(xmlBuff); // gengming	//ehl_con->readxml(tempStr);//	xml_type = get_xmltype(ehl_con->ptag);	ehl_con->xpath_gettext("valdate", valdate);	printf("valdate = %s\n", valdate.c_str());	if (2 == xml_type)	{		viodata = new c_data_convert_xxviodata(ehl_con->ptag);		iresult = viodata->get_viodata_xml(strxml);		delete(viodata);		printf(strxml.c_str());		if (iresult == 0){			iresult = upload_data_inviocar(strxml.c_str(), reftest);			if (iresult != 0)			{				return iresult;			}			WriteLog(xmlBuff);			WriteLog(strxml.c_str());		}	}	else if (1 == xml_type)	{		passcar = new c_data_convert_xxpasscar(ehl_con->ptag);		iresult = passcar->get_passcar_xml(strxml);		delete(passcar);		//printf("%s",strxml);		if (iresult == 0){			iresult = upload_data_inpasscar(strxml.c_str(), reftest);			//printf("iresult = %d\n",iresult);			if (iresult != 0)			{				delete(ehl_con);				return iresult;			}		}	}	else	{		delete(ehl_con);		WriteLog(xmlBuff);		return 111;	}	delete(ehl_con);	return 0;}